/*마트에서 장을 보고 박스를 포장하려고 합니다. 박스를 포장하는 데는 폭이 너무 좁습니다. 그렇기에 한 줄로 서 있어야 하고, 들어온 순서대로 한 명씩 나가야 합니다.

불행 중 다행은, 인원에 맞게 포장할 수 있는 기구들이 놓여 있어, 모두가 포장을 할 수 있다는 것입니다. 짐이 많은 사람은 짐이 적은 사람보다 포장하는 시간이 길 수밖에 없습니다.

뒷사람이 포장을 전부 끝냈어도 앞사람이 끝내지 못하면 기다려야 합니다. 앞사람이 포장을 끝내면, 포장을 마친 뒷사람들과 함께 한 번에 나가게 됩니다.

만약, 앞사람의 박스는 5 개고, 뒷사람 1의 박스는 4 개, 뒷사람 2의 박스는 8 개라고 가정했을 때, 뒷사람 1이 제일 먼저 박스 포장을 끝내게 되어도 앞사람 1의 포장이 마칠 때까지 기다렸다가 같이 나가게 됩니다.

이때, 통틀어 최대 몇 명이 한꺼번에 나가는지 알 수 있도록 함수를 구현해 주세요.


주의 사항
먼저 포장을 전부 끝낸 사람이 있더라도, 앞사람이 포장을 끝내지 않았다면 나갈 수 없습니다.

 */

function paveBox(boxes) {
    // TODO: 여기에 코드를 작성합니다.
    // 들어온 순서대로 한 명씩 나가야 합니다. => first in first out
    // 최대 몇 명이 한꺼번에 나가는지 알 수 있도록 
    // head 인덱스 보다 작은 값을 가진 인덱스들은 모두 같이 나갈 수 있다.
    //포문돌려서 head보다 작은 인덱스일때까지 카운트한다.
    let people = []
    let cnt = 0
    let head = 0
  
  // [5, 1, 4, 6, 4, 5, 6, 9, 3, 1, 7, 5, 4, 6]
    for(let i =0; i <boxes.length; i++){
      if(boxes[head] >= boxes[i] ){
        people.push(boxes[i]) // 헤드인덱스의 값보다 같거나 작은 값들은 한번에 나갈 수 있으므로 people 배열에 푸쉬해준다.
      }else{ // 헤드인덱스의 값보다 큰 값이 출현한다면, 그 인덱스는 한꺼번에 나갈 수 없기떄문에 
        head = i // 인덱스의 위치를 바꿔준다 => findIndex 역할. (생각안났음.)
        cnt < people.length ? cnt = people.length : cnt = cnt //한번에 나갈 수 있는 사람 수를 저장한다.
        people = [] // people배열을 초기화한다.   
        people.push(boxes[i])
      }
    }
    if(people.length > cnt){
      cnt = people.length
    }
    return cnt 
  } 